# DEV-401: Hackathon 比赛平台 - 活动信息上链（Admin 平台 - 主办方功能）开发文档

## 1. 文档说明

### 1.1 文档目的
本文档针对 PRD-401 中 3.1.1 章节「活动信息上链 - Admin 平台主办方功能」提供详细的技术实现方案和开发指导，包括智能合约设计、数据结构定义、接口规范和实现细节。

### 1.2 文档范围
本文档涵盖以下功能模块的开发：
- 3.1.1.1 活动创建上链
- 3.1.1.2 活动编辑上链
- 3.1.1.3 活动删除上链
- 3.1.1.4 活动查询上链

### 1.3 参考文档
- PRD-401: Hackathon 比赛平台 - 第四期需求文档
- tpl/prd_rules_contract.md: 合约开发规范

## 2. 合约架构设计

### 2.1 整体架构

```
┌─────────────────────────────────────────────────────┐
│                 Admin Platform                       │
│            (主办方操作界面)                          │
└────────────────────┬────────────────────────────────┘
                     │
                     │ HTTP API
                     ▼
┌─────────────────────────────────────────────────────┐
│              Backend Service                         │
│         (活动管理、权限验证)                         │
└────────────────────┬────────────────────────────────┘
                     │
                     │ Web3.js/Ethers.js
                     ▼
┌─────────────────────────────────────────────────────┐
│           EventInfoContract                          │
│      (活动信息链上记录智能合约)                      │
│                                                       │
│  - createEvent()    创建活动上链                     │
│  - updateEvent()    编辑活动上链                     │
│  - deleteEvent()    删除活动上链                     │
│  - getEvent()       查询活动链上记录                 │
│  - getEventHistory() 查询活动变更历史                │
│                                                       │
└─────────────────────────────────────────────────────┘
                     │
                     │ 存储
                     ▼
┌─────────────────────────────────────────────────────┐
│            Sepolia Testnet                           │
│         (区块链存储层)                               │
└─────────────────────────────────────────────────────┘
```

### 2.2 技术栈选择

#### 2.2.1 合约技术栈
- **Solidity**: ^0.8.21
- **HardHat**: ^2.19.0
- **openzeppelin/contracts**: ^5.0.0
- **dotenv**: ^16.3.1

#### 2.2.2 网络
- **开发测试网络**: Sepolia

#### 2.2.3 源码验证
- **Sourcify**: 去中心化源码验证
- **Etherscan**: 中心化源码验证
- **要求**: 两者都需要完成验证

#### 2.2.4 部署
- 使用 Hardhat 部署脚本
- 部署前需配置 `.env` 文件（私钥、RPC URL、API Key）
- 部署后记录合约地址到配置文件

## 3. 数据设计

### 3.1 数据结构

#### 3.1.1 EventInfo 结构体

```solidity
struct EventInfo {
    uint256 eventId;           // 活动 ID（数据库主键）
    string eventName;          // 活动名称
    string description;        // 活动描述
    uint256 startTime;         // 开始时间（Unix 时间戳）
    uint256 endTime;           // 结束时间（Unix 时间戳）
    string location;           // 活动地点
    address organizer;         // 主办方钱包地址
    uint256 createdAt;         // 创建时间（区块时间戳）
    uint256 updatedAt;         // 最后更新时间（区块时间戳）
    bool isDeleted;            // 是否已删除
}
```

#### 3.1.2 EventHistory 结构体

```solidity
struct EventHistory {
    uint256 eventId;           // 活动 ID
    uint8 operationType;       // 操作类型: 1=创建, 2=编辑, 3=删除
    uint256 timestamp;         // 操作时间戳
    address operator;          // 操作者地址
    string changeDescription;  // 变更描述
    bytes32 txHash;            // 交易哈希（记录）
}
```

### 3.2 事件

#### 3.2.1 EventCreated 事件

```solidity
event EventCreated(
    uint256 indexed eventId,
    address indexed organizer,
    string eventName,
    uint256 startTime,
    uint256 endTime,
    uint256 timestamp
);
```

#### 3.2.2 EventUpdated 事件

```solidity
event EventUpdated(
    uint256 indexed eventId,
    address indexed operator,
    string changeDescription,
    uint256 timestamp
);
```

#### 3.2.3 EventDeleted 事件

```solidity
event EventDeleted(
    uint256 indexed eventId,
    address indexed operator,
    uint256 timestamp
);
```

## 4. 智能合约实现

### 4.1 EventInfoContract 合约

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.21;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";

/**
 * @title EventInfoContract
 * @dev 管理 Hackathon 活动信息的链上记录合约
 * @notice 本合约用于存储活动的创建、编辑、删除操作记录
 */
contract EventInfoContract is Ownable, ReentrancyGuard {
    
    // 活动信息映射: eventId => EventInfo
    mapping(uint256 => EventInfo) public events;
    
    // 活动历史记录: eventId => EventHistory[]
    mapping(uint256 => EventHistory[]) public eventHistories;
    
    // 主办方授权映射: organizerAddress => isAuthorized
    mapping(address => bool) public authorizedOrganizers;
    
    // 活动 ID 集合
    uint256[] public eventIds;
    
    // 数据结构定义
    struct EventInfo {
        uint256 eventId;
        string eventName;
        string description;
        uint256 startTime;
        uint256 endTime;
        string location;
        address organizer;
        uint256 createdAt;
        uint256 updatedAt;
        bool isDeleted;
    }
    
    struct EventHistory {
        uint256 eventId;
        uint8 operationType;
        uint256 timestamp;
        address operator;
        string changeDescription;
    }
    
    // 事件定义
    event EventCreated(
        uint256 indexed eventId,
        address indexed organizer,
        string eventName,
        uint256 startTime,
        uint256 endTime,
        uint256 timestamp
    );
    
    event EventUpdated(
        uint256 indexed eventId,
        address indexed operator,
        string changeDescription,
        uint256 timestamp
    );
    
    event EventDeleted(
        uint256 indexed eventId,
        address indexed operator,
        uint256 timestamp
    );
    
    event OrganizerAuthorized(address indexed organizer, uint256 timestamp);
    event OrganizerRevoked(address indexed organizer, uint256 timestamp);
    
    // 修饰器
    modifier onlyAuthorizedOrganizer() {
        require(
            authorizedOrganizers[msg.sender] || msg.sender == owner(),
            "Not authorized organizer"
        );
        _;
    }
    
    modifier eventExists(uint256 _eventId) {
        require(events[_eventId].eventId != 0, "Event does not exist");
        _;
    }
    
    modifier eventNotDeleted(uint256 _eventId) {
        require(!events[_eventId].isDeleted, "Event has been deleted");
        _;
    }
    
    constructor() Ownable(msg.sender) {}
    
    /**
     * @dev 授权主办方
     * @param _organizer 主办方地址
     */
    function authorizeOrganizer(address _organizer) external onlyOwner {
        require(_organizer != address(0), "Invalid address");
        authorizedOrganizers[_organizer] = true;
        emit OrganizerAuthorized(_organizer, block.timestamp);
    }
    
    /**
     * @dev 撤销主办方授权
     * @param _organizer 主办方地址
     */
    function revokeOrganizer(address _organizer) external onlyOwner {
        authorizedOrganizers[_organizer] = false;
        emit OrganizerRevoked(_organizer, block.timestamp);
    }
    
    /**
     * @dev 创建活动上链
     * @param _eventId 活动 ID
     * @param _eventName 活动名称
     * @param _description 活动描述
     * @param _startTime 开始时间
     * @param _endTime 结束时间
     * @param _location 活动地点
     */
    function createEvent(
        uint256 _eventId,
        string memory _eventName,
        string memory _description,
        uint256 _startTime,
        uint256 _endTime,
        string memory _location
    ) external onlyAuthorizedOrganizer nonReentrant {
        require(_eventId != 0, "Invalid event ID");
        require(events[_eventId].eventId == 0, "Event already exists");
        require(bytes(_eventName).length > 0, "Event name cannot be empty");
        require(_startTime < _endTime, "Invalid time range");
        
        EventInfo memory newEvent = EventInfo({
            eventId: _eventId,
            eventName: _eventName,
            description: _description,
            startTime: _startTime,
            endTime: _endTime,
            location: _location,
            organizer: msg.sender,
            createdAt: block.timestamp,
            updatedAt: block.timestamp,
            isDeleted: false
        });
        
        events[_eventId] = newEvent;
        eventIds.push(_eventId);
        
        // 记录历史
        _addHistory(
            _eventId,
            1, // 创建操作
            msg.sender,
            "Event created"
        );
        
        emit EventCreated(
            _eventId,
            msg.sender,
            _eventName,
            _startTime,
            _endTime,
            block.timestamp
        );
    }
    
    /**
     * @dev 编辑活动上链
     * @param _eventId 活动 ID
     * @param _eventName 活动名称
     * @param _description 活动描述
     * @param _startTime 开始时间
     * @param _endTime 结束时间
     * @param _location 活动地点
     * @param _changeDescription 变更描述
     */
    function updateEvent(
        uint256 _eventId,
        string memory _eventName,
        string memory _description,
        uint256 _startTime,
        uint256 _endTime,
        string memory _location,
        string memory _changeDescription
    ) external 
        onlyAuthorizedOrganizer 
        eventExists(_eventId) 
        eventNotDeleted(_eventId) 
        nonReentrant 
    {
        require(bytes(_eventName).length > 0, "Event name cannot be empty");
        require(_startTime < _endTime, "Invalid time range");
        
        EventInfo storage eventInfo = events[_eventId];
        
        // 检查活动状态（已开始或已结束的活动不可编辑）
        require(block.timestamp < eventInfo.startTime, "Cannot edit started or ended event");
        
        // 更新活动信息
        eventInfo.eventName = _eventName;
        eventInfo.description = _description;
        eventInfo.startTime = _startTime;
        eventInfo.endTime = _endTime;
        eventInfo.location = _location;
        eventInfo.updatedAt = block.timestamp;
        
        // 记录历史
        _addHistory(
            _eventId,
            2, // 编辑操作
            msg.sender,
            _changeDescription
        );
        
        emit EventUpdated(
            _eventId,
            msg.sender,
            _changeDescription,
            block.timestamp
        );
    }
    
    /**
     * @dev 删除活动上链
     * @param _eventId 活动 ID
     */
    function deleteEvent(uint256 _eventId) 
        external 
        onlyAuthorizedOrganizer 
        eventExists(_eventId) 
        eventNotDeleted(_eventId) 
        nonReentrant 
    {
        EventInfo storage eventInfo = events[_eventId];
        
        // 检查活动状态（已开始或已结束的活动不可删除）
        require(block.timestamp < eventInfo.startTime, "Cannot delete started or ended event");
        
        // 标记为已删除
        eventInfo.isDeleted = true;
        eventInfo.updatedAt = block.timestamp;
        
        // 记录历史
        _addHistory(
            _eventId,
            3, // 删除操作
            msg.sender,
            "Event deleted"
        );
        
        emit EventDeleted(_eventId, msg.sender, block.timestamp);
    }
    
    /**
     * @dev 查询活动信息
     * @param _eventId 活动 ID
     * @return EventInfo 活动信息
     */
    function getEvent(uint256 _eventId) 
        external 
        view 
        eventExists(_eventId) 
        returns (EventInfo memory) 
    {
        return events[_eventId];
    }
    
    /**
     * @dev 查询活动历史记录
     * @param _eventId 活动 ID
     * @return EventHistory[] 活动历史记录数组
     */
    function getEventHistory(uint256 _eventId) 
        external 
        view 
        eventExists(_eventId) 
        returns (EventHistory[] memory) 
    {
        return eventHistories[_eventId];
    }
    
    /**
     * @dev 批量查询活动信息
     * @param _eventIds 活动 ID 数组
     * @return EventInfo[] 活动信息数组
     */
    function getEvents(uint256[] memory _eventIds) 
        external 
        view 
        returns (EventInfo[] memory) 
    {
        EventInfo[] memory result = new EventInfo[](_eventIds.length);
        for (uint256 i = 0; i < _eventIds.length; i++) {
            if (events[_eventIds[i]].eventId != 0) {
                result[i] = events[_eventIds[i]];
            }
        }
        return result;
    }
    
    /**
     * @dev 获取所有活动 ID
     * @return uint256[] 活动 ID 数组
     */
    function getAllEventIds() external view returns (uint256[] memory) {
        return eventIds;
    }
    
    /**
     * @dev 内部函数：添加历史记录
     */
    function _addHistory(
        uint256 _eventId,
        uint8 _operationType,
        address _operator,
        string memory _changeDescription
    ) private {
        EventHistory memory history = EventHistory({
            eventId: _eventId,
            operationType: _operationType,
            timestamp: block.timestamp,
            operator: _operator,
            changeDescription: _changeDescription
        });
        
        eventHistories[_eventId].push(history);
    }
}
```

## 5. 后端服务实现

### 5.1 合约交互服务

#### 5.1.1 EventContractService

```go
package contract

import (
    "context"
    "math/big"
    "github.com/ethereum/go-ethereum/accounts/abi/bind"
    "github.com/ethereum/go-ethereum/common"
    "github.com/ethereum/go-ethereum/ethclient"
)

type EventContractService struct {
    client          *ethclient.Client
    contractAddress common.Address
    contract        *EventInfoContract // 生成的合约绑定
}

// NewEventContractService 创建合约服务实例
func NewEventContractService(rpcURL string, contractAddr string) (*EventContractService, error) {
    client, err := ethclient.Dial(rpcURL)
    if err != nil {
        return nil, err
    }
    
    address := common.HexToAddress(contractAddr)
    contract, err := NewEventInfoContract(address, client)
    if err != nil {
        return nil, err
    }
    
    return &EventContractService{
        client:          client,
        contractAddress: address,
        contract:        contract,
    }, nil
}

// CreateEvent 创建活动上链
func (s *EventContractService) CreateEvent(
    auth *bind.TransactOpts,
    eventID uint64,
    eventName string,
    description string,
    startTime uint64,
    endTime uint64,
    location string,
) (string, error) {
    tx, err := s.contract.CreateEvent(
        auth,
        big.NewInt(int64(eventID)),
        eventName,
        description,
        big.NewInt(int64(startTime)),
        big.NewInt(int64(endTime)),
        location,
    )
    if err != nil {
        return "", err
    }
    
    return tx.Hash().Hex(), nil
}

// UpdateEvent 编辑活动上链
func (s *EventContractService) UpdateEvent(
    auth *bind.TransactOpts,
    eventID uint64,
    eventName string,
    description string,
    startTime uint64,
    endTime uint64,
    location string,
    changeDescription string,
) (string, error) {
    tx, err := s.contract.UpdateEvent(
        auth,
        big.NewInt(int64(eventID)),
        eventName,
        description,
        big.NewInt(int64(startTime)),
        big.NewInt(int64(endTime)),
        location,
        changeDescription,
    )
    if err != nil {
        return "", err
    }
    
    return tx.Hash().Hex(), nil
}

// DeleteEvent 删除活动上链
func (s *EventContractService) DeleteEvent(
    auth *bind.TransactOpts,
    eventID uint64,
) (string, error) {
    tx, err := s.contract.DeleteEvent(
        auth,
        big.NewInt(int64(eventID)),
    )
    if err != nil {
        return "", err
    }
    
    return tx.Hash().Hex(), nil
}

// GetEvent 查询活动信息
func (s *EventContractService) GetEvent(eventID uint64) (*EventInfo, error) {
    opts := &bind.CallOpts{
        Context: context.Background(),
    }
    
    event, err := s.contract.GetEvent(opts, big.NewInt(int64(eventID)))
    if err != nil {
        return nil, err
    }
    
    return &EventInfo{
        EventID:     event.EventId.Uint64(),
        EventName:   event.EventName,
        Description: event.Description,
        StartTime:   event.StartTime.Uint64(),
        EndTime:     event.EndTime.Uint64(),
        Location:    event.Location,
        Organizer:   event.Organizer.Hex(),
        CreatedAt:   event.CreatedAt.Uint64(),
        UpdatedAt:   event.UpdatedAt.Uint64(),
        IsDeleted:   event.IsDeleted,
    }, nil
}

// GetEventHistory 查询活动历史记录
func (s *EventContractService) GetEventHistory(eventID uint64) ([]*EventHistory, error) {
    opts := &bind.CallOpts{
        Context: context.Background(),
    }
    
    histories, err := s.contract.GetEventHistory(opts, big.NewInt(int64(eventID)))
    if err != nil {
        return nil, err
    }
    
    result := make([]*EventHistory, len(histories))
    for i, h := range histories {
        result[i] = &EventHistory{
            EventID:           h.EventId.Uint64(),
            OperationType:     h.OperationType,
            Timestamp:         h.Timestamp.Uint64(),
            Operator:          h.Operator.Hex(),
            ChangeDescription: h.ChangeDescription,
        }
    }
    
    return result, nil
}
```

### 5.2 API 接口设计

#### 5.2.1 创建活动接口

**请求**

```http
POST /api/admin/events
Content-Type: application/json
Authorization: Bearer {token}

{
    "event_name": "Web3 Hackathon 2024",
    "description": "全球最大的 Web3 黑客松比赛",
    "start_time": 1704067200,
    "end_time": 1704153600,
    "location": "上海国际会议中心"
}
```

**响应**

```json
{
    "code": 0,
    "message": "success",
    "data": {
        "event_id": 1001,
        "tx_hash": "0x1234567890abcdef...",
        "status": "pending"
    }
}
```

#### 5.2.2 编辑活动接口

**请求**

```http
PUT /api/admin/events/{event_id}
Content-Type: application/json
Authorization: Bearer {token}

{
    "event_name": "Web3 Hackathon 2024 (Updated)",
    "description": "全球最大的 Web3 黑客松比赛 - 新增奖池",
    "start_time": 1704067200,
    "end_time": 1704153600,
    "location": "上海国际会议中心",
    "change_description": "更新活动名称和描述"
}
```

**响应**

```json
{
    "code": 0,
    "message": "success",
    "data": {
        "event_id": 1001,
        "tx_hash": "0xabcdef1234567890...",
        "status": "pending"
    }
}
```

#### 5.2.3 删除活动接口

**请求**

```http
DELETE /api/admin/events/{event_id}
Authorization: Bearer {token}
```

**响应**

```json
{
    "code": 0,
    "message": "success",
    "data": {
        "event_id": 1001,
        "tx_hash": "0xfedcba0987654321...",
        "status": "pending"
    }
}
```

#### 5.2.4 查询活动接口

**请求**

```http
GET /api/admin/events/{event_id}
Authorization: Bearer {token}
```

**响应**

```json
{
    "code": 0,
    "message": "success",
    "data": {
        "event_id": 1001,
        "event_name": "Web3 Hackathon 2024",
        "description": "全球最大的 Web3 黑客松比赛",
        "start_time": 1704067200,
        "end_time": 1704153600,
        "location": "上海国际会议中心",
        "organizer": "0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb",
        "created_at": 1703980800,
        "updated_at": 1703980800,
        "is_deleted": false,
        "chain_data": {
            "tx_hashes": [
                "0x1234567890abcdef...",
                "0xabcdef1234567890..."
            ],
            "verified": true
        }
    }
}
```

#### 5.2.5 查询活动历史接口

**请求**

```http
GET /api/admin/events/{event_id}/history
Authorization: Bearer {token}
```

**响应**

```json
{
    "code": 0,
    "message": "success",
    "data": {
        "event_id": 1001,
        "histories": [
            {
                "operation_type": 1,
                "operation_name": "创建",
                "timestamp": 1703980800,
                "operator": "0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb",
                "change_description": "Event created"
            },
            {
                "operation_type": 2,
                "operation_name": "编辑",
                "timestamp": 1703981800,
                "operator": "0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb",
                "change_description": "更新活动名称和描述"
            }
        ]
    }
}
```

## 6. 异常处理

### 6.1 钱包余额不足

**场景**: 主办方钱包 Gas 费不足

**处理**:
1. 在调用合约前，检查钱包余额
2. 预估 Gas 费用
3. 如果余额不足，返回错误

**错误响应**:

```json
{
    "code": 4001,
    "message": "钱包余额不足，需要至少 0.01 ETH 用于支付 Gas 费",
    "data": {
        "current_balance": "0.005",
        "required_balance": "0.01",
        "unit": "ETH"
    }
}
```

### 6.2 链上写入失败

**场景**: 区块链网络拥堵或交易失败

**处理**:
1. 捕获交易错误
2. 记录错误日志
3. 提供重试机制

**错误响应**:

```json
{
    "code": 5001,
    "message": "链上写入失败，请稍后重试",
    "data": {
        "error": "transaction underpriced",
        "retry_available": true
    }
}
```

### 6.3 活动状态异常

**场景**: 活动已开始或已结束

**处理**:
1. 验证活动当前状态
2. 根据操作类型检查是否允许

**错误响应**:

```json
{
    "code": 4002,
    "message": "活动已开始，无法编辑或删除",
    "data": {
        "event_id": 1001,
        "current_status": "ongoing"
    }
}
```

## 7. 数据一致性保证

### 7.1 双写机制

1. **数据库写入**: 先写入数据库，生成 event_id
2. **区块链写入**: 使用 event_id 写入区块链
3. **交易记录**: 记录交易哈希到数据库
4. **状态更新**: 监听交易状态，更新数据库

### 7.2 数据验证

```go
// VerifyEventData 验证活动数据一致性
func (s *EventService) VerifyEventData(eventID uint64) (*VerifyResult, error) {
    // 1. 从数据库获取活动信息
    dbEvent, err := s.repo.GetEventByID(eventID)
    if err != nil {
        return nil, err
    }
    
    // 2. 从区块链获取活动信息
    chainEvent, err := s.contractService.GetEvent(eventID)
    if err != nil {
        return nil, err
    }
    
    // 3. 对比数据一致性
    result := &VerifyResult{
        EventID:  eventID,
        Verified: true,
    }
    
    if dbEvent.EventName != chainEvent.EventName {
        result.Verified = false
        result.Differences = append(result.Differences, "event_name")
    }
    
    if dbEvent.Description != chainEvent.Description {
        result.Verified = false
        result.Differences = append(result.Differences, "description")
    }
    
    // ... 其他字段对比
    
    return result, nil
}
```

## 8. 部署流程

### 8.1 环境配置

创建 `.env` 文件:

```env
# Sepolia 网络配置
SEPOLIA_RPC_URL=https://sepolia.infura.io/v3/YOUR_INFURA_KEY
PRIVATE_KEY=your_private_key_here

# Etherscan API Key
ETHERSCAN_API_KEY=your_etherscan_api_key

# 合约部署参数
INITIAL_OWNER=0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb
```

### 8.2 部署脚本

创建 `scripts/deploy-event-contract.js`:

```javascript
const { ethers } = require("hardhat");

async function main() {
    console.log("开始部署 EventInfoContract...");
    
    // 获取部署账户
    const [deployer] = await ethers.getSigners();
    console.log("部署账户:", deployer.address);
    
    // 获取合约工厂
    const EventInfoContract = await ethers.getContractFactory("EventInfoContract");
    
    // 部署合约
    const contract = await EventInfoContract.deploy();
    await contract.waitForDeployment();
    
    const contractAddress = await contract.getAddress();
    console.log("EventInfoContract 部署成功！");
    console.log("合约地址:", contractAddress);
    
    // 等待几个区块确认
    console.log("等待区块确认...");
    await contract.deploymentTransaction().wait(5);
    
    // 验证合约
    console.log("开始验证合约...");
    await hre.run("verify:verify", {
        address: contractAddress,
        constructorArguments: [],
    });
    
    console.log("合约验证完成！");
}

main()
    .then(() => process.exit(0))
    .catch((error) => {
        console.error(error);
        process.exit(1);
    });
```

### 8.3 执行部署

```bash
# 编译合约
npx hardhat compile

# 部署到 Sepolia
npx hardhat run scripts/deploy-event-contract.js --network sepolia

# 记录合约地址到配置文件
```

### 8.4 合约验证

```bash
# Etherscan 验证
npx hardhat verify --network sepolia DEPLOYED_CONTRACT_ADDRESS

# Sourcify 验证（自动）
```

## 9. 测试方案

### 9.1 单元测试

```javascript
const { expect } = require("chai");
const { ethers } = require("hardhat");

describe("EventInfoContract", function () {
    let eventContract;
    let owner;
    let organizer;
    
    beforeEach(async function () {
        [owner, organizer] = await ethers.getSigners();
        
        const EventInfoContract = await ethers.getContractFactory("EventInfoContract");
        eventContract = await EventInfoContract.deploy();
        await eventContract.waitForDeployment();
        
        // 授权主办方
        await eventContract.authorizeOrganizer(organizer.address);
    });
    
    describe("createEvent", function () {
        it("应该成功创建活动", async function () {
            const eventId = 1001;
            const eventName = "Test Hackathon";
            const description = "Test Description";
            const startTime = Math.floor(Date.now() / 1000) + 86400;
            const endTime = startTime + 86400;
            const location = "Test Location";
            
            await expect(
                eventContract.connect(organizer).createEvent(
                    eventId,
                    eventName,
                    description,
                    startTime,
                    endTime,
                    location
                )
            ).to.emit(eventContract, "EventCreated")
             .withArgs(eventId, organizer.address, eventName, startTime, endTime, anyValue);
            
            const event = await eventContract.getEvent(eventId);
            expect(event.eventName).to.equal(eventName);
            expect(event.description).to.equal(description);
        });
        
        it("非授权主办方应该无法创建活动", async function () {
            const [, , unauthorized] = await ethers.getSigners();
            
            await expect(
                eventContract.connect(unauthorized).createEvent(
                    1002,
                    "Unauthorized Event",
                    "Description",
                    Math.floor(Date.now() / 1000) + 86400,
                    Math.floor(Date.now() / 1000) + 172800,
                    "Location"
                )
            ).to.be.revertedWith("Not authorized organizer");
        });
        
        it("应该拒绝重复的活动 ID", async function () {
            const eventId = 1003;
            const startTime = Math.floor(Date.now() / 1000) + 86400;
            const endTime = startTime + 86400;
            
            await eventContract.connect(organizer).createEvent(
                eventId,
                "Event 1",
                "Description 1",
                startTime,
                endTime,
                "Location 1"
            );
            
            await expect(
                eventContract.connect(organizer).createEvent(
                    eventId,
                    "Event 2",
                    "Description 2",
                    startTime,
                    endTime,
                    "Location 2"
                )
            ).to.be.revertedWith("Event already exists");
        });
    });
    
    describe("updateEvent", function () {
        let eventId;
        let startTime;
        let endTime;
        
        beforeEach(async function () {
            eventId = 2001;
            startTime = Math.floor(Date.now() / 1000) + 86400;
            endTime = startTime + 86400;
            
            await eventContract.connect(organizer).createEvent(
                eventId,
                "Original Event",
                "Original Description",
                startTime,
                endTime,
                "Original Location"
            );
        });
        
        it("应该成功编辑活动", async function () {
            const newEventName = "Updated Event";
            const newDescription = "Updated Description";
            
            await expect(
                eventContract.connect(organizer).updateEvent(
                    eventId,
                    newEventName,
                    newDescription,
                    startTime,
                    endTime,
                    "Updated Location",
                    "更新活动信息"
                )
            ).to.emit(eventContract, "EventUpdated");
            
            const event = await eventContract.getEvent(eventId);
            expect(event.eventName).to.equal(newEventName);
            expect(event.description).to.equal(newDescription);
        });
        
        it("应该拒绝编辑已开始的活动", async function () {
            // 创建一个已开始的活动
            const pastEventId = 2002;
            const pastStartTime = Math.floor(Date.now() / 1000) - 3600;
            const pastEndTime = Math.floor(Date.now() / 1000) + 3600;
            
            await eventContract.connect(organizer).createEvent(
                pastEventId,
                "Past Event",
                "Description",
                pastStartTime,
                pastEndTime,
                "Location"
            );
            
            // 等待时间经过（在测试中可以使用 time.increase）
            // await time.increase(7200);
            
            // 尝试编辑
            // await expect(
            //     eventContract.connect(organizer).updateEvent(
            //         pastEventId,
            //         "Updated Name",
            //         "Updated Description",
            //         pastStartTime,
            //         pastEndTime,
            //         "Updated Location",
            //         "尝试更新"
            //     )
            // ).to.be.revertedWith("Cannot edit started or ended event");
        });
    });
    
    describe("deleteEvent", function () {
        let eventId;
        
        beforeEach(async function () {
            eventId = 3001;
            const startTime = Math.floor(Date.now() / 1000) + 86400;
            const endTime = startTime + 86400;
            
            await eventContract.connect(organizer).createEvent(
                eventId,
                "Event to Delete",
                "Description",
                startTime,
                endTime,
                "Location"
            );
        });
        
        it("应该成功删除活动", async function () {
            await expect(
                eventContract.connect(organizer).deleteEvent(eventId)
            ).to.emit(eventContract, "EventDeleted");
            
            const event = await eventContract.getEvent(eventId);
            expect(event.isDeleted).to.be.true;
        });
    });
    
    describe("getEventHistory", function () {
        it("应该正确记录活动历史", async function () {
            const eventId = 4001;
            const startTime = Math.floor(Date.now() / 1000) + 86400;
            const endTime = startTime + 86400;
            
            // 创建活动
            await eventContract.connect(organizer).createEvent(
                eventId,
                "History Event",
                "Description",
                startTime,
                endTime,
                "Location"
            );
            
            // 编辑活动
            await eventContract.connect(organizer).updateEvent(
                eventId,
                "Updated Event",
                "Updated Description",
                startTime,
                endTime,
                "Location",
                "第一次更新"
            );
            
            // 获取历史记录
            const histories = await eventContract.getEventHistory(eventId);
            
            expect(histories.length).to.equal(2);
            expect(histories[0].operationType).to.equal(1); // 创建
            expect(histories[1].operationType).to.equal(2); // 编辑
        });
    });
});
```

### 9.2 集成测试

```bash
# 运行所有测试
npx hardhat test

# 运行特定测试
npx hardhat test test/EventInfoContract.test.js

# 查看测试覆盖率
npx hardhat coverage
```

## 10. 监控和日志

### 10.1 事件监听

```go
// 监听 EventCreated 事件
func (s *EventContractService) WatchEventCreated(ctx context.Context) error {
    eventCreatedChan := make(chan *EventInfoContractEventCreated)
    
    sub, err := s.contract.WatchEventCreated(
        &bind.WatchOpts{Context: ctx},
        eventCreatedChan,
        nil, // eventId filter
        nil, // organizer filter
    )
    if err != nil {
        return err
    }
    defer sub.Unsubscribe()
    
    for {
        select {
        case event := <-eventCreatedChan:
            // 处理事件
            log.Printf("EventCreated: eventId=%d, organizer=%s, txHash=%s",
                event.EventId.Uint64(),
                event.Organizer.Hex(),
                event.Raw.TxHash.Hex(),
            )
            
            // 更新数据库状态
            s.updateEventStatus(event.EventId.Uint64(), "confirmed", event.Raw.TxHash.Hex())
            
        case err := <-sub.Err():
            log.Printf("Event subscription error: %v", err)
            return err
            
        case <-ctx.Done():
            return ctx.Err()
        }
    }
}
```

### 10.2 交易状态查询

```go
// CheckTransactionStatus 查询交易状态
func (s *EventContractService) CheckTransactionStatus(txHash string) (*TransactionStatus, error) {
    hash := common.HexToHash(txHash)
    
    // 查询交易回执
    receipt, err := s.client.TransactionReceipt(context.Background(), hash)
    if err != nil {
        return nil, err
    }
    
    status := &TransactionStatus{
        TxHash:       txHash,
        BlockNumber:  receipt.BlockNumber.Uint64(),
        GasUsed:      receipt.GasUsed,
        Status:       receipt.Status, // 1=成功, 0=失败
    }
    
    return status, nil
}
```

## 11. 开发规范

### 11.1 代码规范

#### 11.1.1 命名规范

- **合约名称**: 使用 PascalCase，如 `EventInfoContract`
- **函数名称**: 使用 camelCase，如 `createEvent`
- **变量名称**: 使用 camelCase，如 `eventId`
- **常量名称**: 使用 UPPER_SNAKE_CASE，如 `MAX_EVENT_COUNT`
- **事件名称**: 使用 PascalCase，如 `EventCreated`

#### 11.1.2 注释规范

```solidity
/**
 * @dev 创建活动上链
 * @param _eventId 活动 ID（数据库主键）
 * @param _eventName 活动名称
 * @param _description 活动描述
 * @param _startTime 开始时间（Unix 时间戳）
 * @param _endTime 结束时间（Unix 时间戳）
 * @param _location 活动地点
 * @notice 仅授权主办方可调用此函数
 * @notice 活动 ID 不能重复
 */
function createEvent(
    uint256 _eventId,
    string memory _eventName,
    string memory _description,
    uint256 _startTime,
    uint256 _endTime,
    string memory _location
) external onlyAuthorizedOrganizer nonReentrant {
    // 函数实现
}
```

### 11.2 数据结构规范

- **与后端代码结构体一致**: 确保链上结构体与后端 Go 结构体字段名称和类型对应
- **使用明确的数据类型**: 避免使用 `uint` 等不明确类型，使用 `uint256`
- **添加字段注释**: 每个字段都应有清晰的注释说明

## 12. 安全考虑

### 12.1 访问控制

- 使用 OpenZeppelin 的 `Ownable` 和自定义的授权机制
- 关键操作需要权限验证
- 支持多签管理（未来扩展）

### 12.2 重入攻击防护

- 使用 OpenZeppelin 的 `ReentrancyGuard`
- 所有状态修改函数添加 `nonReentrant` 修饰器

### 12.3 数据验证

- 输入参数严格验证
- 时间范围合法性检查
- 活动状态检查

### 12.4 Gas 优化

- 使用 `memory` 而非 `storage` 读取临时数据
- 批量操作减少交易次数
- 事件日志代替链上存储（历史记录）

## 13. 交付清单

### 13.1 合约代码

- [ ] EventInfoContract.sol
- [ ] 合约测试文件
- [ ] 部署脚本
- [ ] 合约 ABI 文件

### 13.2 后端代码

- [ ] EventContractService (Go)
- [ ] 合约绑定代码
- [ ] API 接口实现
- [ ] 数据验证服务

### 13.3 文档

- [ ] 本开发文档 (DEV401.md)
- [ ] API 接口文档
- [ ] 部署说明文档
- [ ] 测试报告

### 13.4 配置文件

- [ ] hardhat.config.js
- [ ] .env.example
- [ ] 合约地址配置

---

**文档版本**: v1.0  
**创建日期**: 2024-12-29  
**最后更新**: 2024-12-29  
**维护人员**: 开发团队
